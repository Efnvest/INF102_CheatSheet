\documentclass{article}

\usepackage{graphicx} % Required for inserting images
\usepackage{array}
\usepackage{amsmath}
\usepackage{blindtext}
\usepackage{titlesec}

\setlength{\parindent}{0in}
\setlength{\oddsidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8.8in}
\setlength{\topmargin}{0in}
\setlength{\headheight}{18pt}

\title{CheatSheet INF102}
\author{Erik Fjelltveit Nyhuus}
\date{November 2024}

\begin{document}
\maketitle

\tableofcontents

\newpage

% Add binary search algorithm, the two variants. Recurrsion and iterative.
% List of the different sorting algorithems and there sudocode. There usecaese. 
% How to use Collections.sort() Comparator, Comparable.
% Quickselect, better understanding. 
% Exapmle code.
% Priorityqueue, how does it work, where should you use it. What are the implementations.
% Added usefull code from labs to download. 

\section{Sorting Algorithms}
\subsection{Selection sort}
Time Complexity = $O(n^2)$\\
Sorts an array by repeatedly selecting the smallest or largest element from the unsorted portion
and swapping it with the first unsorted element. Continues until list is sorted.
\subsection{Insertion sort}
Time Complexity = $O(n^2)$\\
Simple sorting algorithm that works by iteratively inserting each element of an unsorted list into its correct 
position in a sorted portion of the list. The same algorithm you use when sorting playing cards. 
You pick a card and insert it into the correct relative position. 
\subsection{Bubble sort}
Time Complexity = $O(n^2)$\\
Works by repeatedly swapping the adjacent elements if they are in the wrong order. Continues 
this process until it has a pass with know swaps.
\subsection{Quick sort}
Worst Case = $O(n^2)$ Occures with poor pivot.\\ 
Average Case = $\theta(nlog(n))$\\
Based on divide and conquer, picks an element that is used as a pivot and partitions the array by moving all elements
greater then pivot to the right of pivot and elements less than pivot on the left side. Calls the same algorithm to the know two sub-arrays and repeats the process.
% add more
\subsection{Merge sort}
Average Case = $(nlog(n))$\\
Divide the list into two smaller sublists, continues on dividing until list has size 1. Merges each of the smaller lists in correct order until everything is sorted. 
\subsection{Bucket sort}
Average Case = $(nlog(n))$\\
Worsk if you have repeated elements in a list. Adds elements into different groups based on size. Sort each bucket on it own afterwards. 

\subsection{Radix sort}

\newpage

\section{ArrayList vs. LinkedList}
\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Operation} & \textbf{ArrayList} & \textbf{LinkedList} \\
\hline
size() & O(1) & O(1) \\
\hline
add() & O(n)* & O(1) \\
\hline
contains(obj) & O(n) & O(n) \\
\hline
remove(obj) & O(n) & O(n) \\
\hline
toArray() & O(n) & O(n) \\
\hline
indexOf(obj) & O(n) & O(n) \\
\hline
get(int i) & O(1) & O(n) \\
\hline
set(int i, E e) & O(1) & O(n) \\
\hline
\end{tabular}
\end{table}
\begin{itemize}
  \item *O(1) in amortized time (when resizing is not needed)
\end{itemize}


\section{ArrayList vs. LinkedList (Queue/Stack)}
\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|c|c|}
\hline
& \textbf{ArrayList} & & \textbf{LinkedList} & \\
\hline
& \textbf{Queue} & \textbf{Stack} & \textbf{Queue} & \textbf{Stack} \\
\hline
offer / push & O(n) & O(n)* & O(1) & O(1) \\
\hline
poll / pop & O(1) & O(1) & O(1) & O(1) \\
\hline
peek & O(1) & O(1) & O(1) & O(1) \\
\hline
\end{tabular}
\end{table}
\begin{itemize}
  \item *O(1) in amortized time (when resizing is not needed)
\end{itemize}

\section{PriorityQueue}

\subsection{PriorityQueue}
\begin{table}[h!]
  \centering
  \begin{tabular}{|l|c|}
  \hline
  \textbf{Operation} & \textbf{Time Complexity} \\
  \hline
  add() & O(log(n))\\
  \hline
  remove(Head) & O(log(n))\\
  \hline
  remove(Specific object) & O(n)\\
  \hline
  poll() & O(log(n))\\
  \hline  
  peek() & O(1)\\
  \hline  
  size() & O(1)\\
  \hline  
  \end{tabular}
  \end{table}

\subsection{PriorityQueue - SortedList}
\begin{table}[h!]
\centering
\begin{tabular}{|l|c|}
\hline
\textbf{Operation} & \textbf{Time Complexity} \\
\hline
add(T element) & O(n) \\
\hline
T findMin() & O(1) \\
\hline
T removeMin() & O(1) \\
\hline
\end{tabular}
\end{table}
\subsection{PriorityQueue - LinkedList}
\begin{table}[h!]
\centering
\begin{tabular}{|l|c|}
\hline
\textbf{Operation} & \textbf{Time Complexity} \\
\hline
add(T element) & O(1) \\
\hline
T findMin() & O(n) \\
\hline
T removeMin() & O(n) \\
\hline
\end{tabular}
\end{table}

\newpage


\section{HashSet vs. TreeSet}
\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Operation} & \textbf{HashSet} & \textbf{TreeSet} \\
\hline
add() & O(1)* & O(log(n)) \\
\hline
remove() & O(1)* & O(log(n)) \\
\hline
contains(obj) & O(1)* & O(log(n)) \\
\hline
findMin & O(n) & O(log(n))\\
\hline
findMax & O(n) & O(log(n))\\
\hline
\end{tabular}
\end{table}
\begin{itemize}
  \item *HashSet har O(1) i snitt, men O(n) i worst case
\end{itemize}



\section{Heap runtime}
\begin{table}[h!]
\centering
\begin{tabular}{|l|c|}
\hline
\textbf{Operation} & \textbf{Time Complexity} \\
\hline
add(T element) & O(log(n)) \\
\hline
T peekMin() & O(1) \\
\hline
T removeMin() & O(log(n)) \\
\hline
Construct heap & O(n) \\
\hline
\end{tabular}
\end{table}


\section{Graph Datastructures}
\subsection{EdgeList}
\begin{table}[h!]
\centering
\begin{tabular}{|l|c|}
\hline
\textbf{Metode} & \textbf{Kjøretid} \\
\hline
Adjacent & O(M)* \\
\hline
Vertices & O(M) \\
\hline
Edges & O(N) \\
\hline
Neighbours & O(M)* \\
\hline
AddVertex & O(1)* \\
\hline
AddEdge & O(1)* \\
\hline
\end{tabular}
\end{table}



\subsection{Adjacency Set}
\begin{table}[h!]
\centering
\begin{tabular}{|l|c|}
\hline
\textbf{Metode} & \textbf{Kjøretid} \\
\hline
Adjacent & O(1)* \\
\hline
Vertices & O(1) \\
\hline
Edges & O(M) \\
\hline
Neighbours & O(1)* \\
\hline
AddVertex & O(1)* \\
\hline
AddEdge & O(1)* \\
\hline
\end{tabular}
\end{table}


\subsection{Adjacency List}
\begin{table}[h!]
\centering
\begin{tabular}{|l|c|}
\hline
\textbf{Method} & \textbf{Runtime} \\
\hline
Adjacent & O(degree) \\
\hline
Vertices & O(1) \\
\hline
Edges & O(M) \\
\hline
Neighbours & O(1)* \\
\hline
addVertex & O(N) \\
\hline
addEdge & O(degree) \\
\hline
\end{tabular}
\end{table}

\newpage

\subsection{Adjacency Matrix}
\begin{table}[!ht]
\centering
\begin{tabular}{|l|c|}
\hline
\textbf{Method} & \textbf{Runtime} \\
\hline
Adjacent & $O(1)$ \\
\hline
Vertices & $O(1)$ \\
\hline
Edges & $O(N^2)$ \\
\hline
Neighbours & $O(N)$ \\
\hline 
addVertex & $O(N^2)$ or $O(N)$ \\
\hline
addEdge & $O(1)$ \\
\hline
\end{tabular}
\end{table}


\section{Summary of Graph Algorithms}
\begin{table}[h!]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{Algorithm} & \textbf{Graph Type} & \textbf{Time Complexity} \\
\hline
BFS & Unweighted & \( O(m + n) \) \\
\hline
DFS & Unweighted & \( O(m + n) \)\\
\hline
Dijkstra & Positive weights & \( O(m \log m) \) \\
\hline
Bellman-Ford & Negative weights, no negative cycle & \( O(n \cdot m) \) \\
\hline
Brute-Force & Negative weights & \( 2^{O(n)} \) \\
\hline
$A^*$ &Weighted& $mlog( n )$ \\
\hline
Kruskal's &Weighted& \( O(m \log n) \) \\
\hline
Prim's  &Weighted& \( O(m \log n) \) \\
\hline
Union-Find  && \( O(m \log n)^* \) \\
\hline
\end{tabular}
\caption{Summary of Graph Algorithms}
\end{table}


\end{document}
